{"version":3,"sources":["../src/inputs/parseVitestJsonReports.ts","../src/inputs/getCoverageModeFrom.ts","../src/inputs/getViteConfigPath.ts","../src/inputs/parseCoverageThresholds.ts","../src/inputs/readOptions.ts","../src/report/generateBadges.ts","../src/main.ts"],"names":["parseVitestCoverageReport","jsonPath","resolvedJsonSummaryPath","path","jsonSummaryRaw","readFile","parseVitestJsonSummary","jsonSummaryPath","err","stack","f","stripIndent","FileCoverageMode","getCoverageModeFrom","input","v","testFilePath","workingDirectory","filePath","resolvedPath","fs","constants","defaultPaths","getViteConfigPath","searchPath","j","regex100","regexStatements","regexLines","regexBranches","regexFunctions","parseCoverageThresholds","vitestConfigPath","resolvedViteConfigPath","rawContent","lines","branches","functions","statements","x","readOptions","fileCoverageModeRaw","fileCoverageMode","jsonFinalPath","jsonSummaryCompareInput","jsonSummaryComparePath","name","prNumber","processedPrNumber","viteConfigPath","thresholds","generateUrl","summaryData","summaryKey","percentage","color","downloadBadge","url","filename","resolve","reject","https","res","newError","file","createWriteStream","generateBadges","options","badgesSavedTo","totalCoverageReport","statementsBadgeUrl","branchesBadgeUrl","functionsBadgeUrl","linesBadgeUrl","existsSync","mkdirSync","main","args","argv","minimist","jsonSummary"],"mappings":"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","file":"main.js","sourcesContent":["import { stripIndent } from 'common-tags';\nimport { readFile } from 'node:fs/promises';\nimport path from 'node:path';\nimport * as core from '@actions/core';\nimport type { JsonFinal } from '../types/JsonFinal.js';\nimport type { JsonSummary } from '../types/JsonSummary.js';\n\nconst parseVitestCoverageReport = async <type extends JsonSummary | JsonFinal>(\n  jsonPath: string\n): Promise<type> => {\n  const resolvedJsonSummaryPath = path.resolve(process.cwd(), jsonPath);\n  const jsonSummaryRaw = await readFile(resolvedJsonSummaryPath);\n  return JSON.parse(jsonSummaryRaw.toString()) as type;\n};\n\nexport const parseVitestJsonSummary = async (\n  jsonSummaryPath: string\n): Promise<JsonSummary> => {\n  try {\n    return await parseVitestCoverageReport<JsonSummary>(jsonSummaryPath);\n  } catch (err: unknown) {\n    const stack = err instanceof Error ? err.stack : '';\n    core.setFailed(stripIndent`\n        Failed to parse the json-summary at path \"${jsonSummaryPath}.\"\n        Make sure to run vitest before this action and to include the \"json-summary\" reporter.\n\n        Original Error:\n        ${stack}\n    `);\n\n    // Rethrow to abort the entire workflow\n    throw err;\n  }\n};\n\nexport const parseVitestJsonFinal = async (\n  jsonFinalPath: string\n): Promise<JsonFinal> => {\n  try {\n    return await parseVitestCoverageReport<JsonFinal>(jsonFinalPath);\n  } catch (err: unknown) {\n    const stack = err instanceof Error ? err.stack : '';\n    core.warning(stripIndent`\n      Failed to parse JSON Final at path \"${jsonFinalPath}\".\n      Line coverage will be empty. To include it, make sure to include the \"json\" reporter in your vitest execution.\n\n      Original Error:\n      ${stack}\n    `);\n    return {};\n  }\n};\n","import * as core from '@actions/core';\n\nexport enum FileCoverageMode {\n  All = 'all',\n  Changes = 'changes',\n  None = 'none',\n}\n\nexport function getCoverageModeFrom(input: string): FileCoverageMode {\n  const allEnums = Object.values(FileCoverageMode) as string[];\n  const index = allEnums.indexOf(input);\n  if (index === -1) {\n    core.warning(`Not valid value \"${input}\" for summary mode, used \"changes\"`);\n    return FileCoverageMode.Changes;\n  }\n  return input as FileCoverageMode;\n}\n","import { stripIndent } from 'common-tags';\nimport { constants, promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport * as core from '@actions/core';\n\nconst testFilePath = async (workingDirectory: string, filePath: string) => {\n  const resolvedPath = path.resolve(workingDirectory, filePath);\n  await fs.access(resolvedPath, constants.R_OK);\n  return resolvedPath;\n};\n\nconst defaultPaths = [\n  'vitest.config.ts',\n  'vitest.config.mts',\n  'vitest.config.cts',\n  'vitest.config.js',\n  'vitest.config.mjs',\n  'vitest.config.cjs',\n  'vite.config.ts',\n  'vite.config.mts',\n  'vite.config.cts',\n  'vite.config.js',\n  'vite.config.mjs',\n  'vite.config.cjs',\n  'vitest.workspace.ts',\n  'vitest.workspace.mts',\n  'vitest.workspace.cts',\n  'vitest.workspace.js',\n  'vitest.workspace.mjs',\n  'vitest.workspace.cjs',\n];\n\nexport const getViteConfigPath = async (\n  workingDirectory: string,\n  input: string\n) => {\n  try {\n    if (input === '') {\n      return await Promise.any(\n        defaultPaths.map((filePath) => testFilePath(workingDirectory, filePath))\n      );\n    }\n\n    return await testFilePath(workingDirectory, input);\n  } catch {\n    const searchPath = input\n      ? path.resolve(workingDirectory, input)\n      : `any default location in \"${workingDirectory}\"`;\n\n    core.warning(stripIndent`\n          Failed to read vite config file at ${searchPath}.\n          Make sure you provide the vite-config-path option if you're using a non-default location or name of your config file.\n\n          Will not include thresholds in the final report.\n      `);\n    return null;\n  }\n};\n","import { promises as fs } from 'node:fs';\nimport path from 'node:path';\nimport * as core from '@actions/core';\nimport type { Thresholds } from '../types/Threshold.js';\n\nconst regex100 = /100\"?\\s*:\\s*true/;\nconst regexStatements = /statements\\s*:\\s*(\\d+)/;\nconst regexLines = /lines:\\s*(\\d+)/;\nconst regexBranches = /branches\\s*:\\s*(\\d+)/;\nconst regexFunctions = /functions\\s*:\\s*(\\d+)/;\n\nexport const parseCoverageThresholds = async (\n  vitestConfigPath: string\n): Promise<Thresholds> => {\n  try {\n    const resolvedViteConfigPath = path.resolve(\n      process.cwd(),\n      vitestConfigPath\n    );\n    const rawContent = await fs.readFile(resolvedViteConfigPath, 'utf8');\n\n    const has100Value = rawContent.match(regex100);\n\n    if (has100Value) {\n      return {\n        lines: 100,\n        branches: 100,\n        functions: 100,\n        statements: 100,\n      };\n    }\n\n    const lines = rawContent.match(regexLines);\n    const branches = rawContent.match(regexBranches);\n    const functions = rawContent.match(regexFunctions);\n    const statements = rawContent.match(regexStatements);\n\n    return {\n      lines: lines ? Number.parseInt(lines[1]) : undefined,\n      branches: branches ? Number.parseInt(branches[1]) : undefined,\n      functions: functions ? Number.parseInt(functions[1]) : undefined,\n      statements: statements ? Number.parseInt(statements[1]) : undefined,\n    };\n  } catch (err: unknown) {\n    core.warning(\n      `Could not read vite config file for tresholds due to an error:\\n ${err}`\n    );\n    return {};\n  }\n};\n","import * as path from 'node:path';\nimport * as core from '@actions/core';\nimport { getCoverageModeFrom } from './getCoverageModeFrom.js';\nimport { getViteConfigPath } from './getViteConfigPath.js';\nimport { parseCoverageThresholds } from './parseCoverageThresholds.js';\n\nexport async function readOptions() {\n  // Working directory can be used to modify all default/provided paths (for monorepos, etc)\n  const workingDirectory = core.getInput('working-directory');\n\n  // all/changes/none\n  const fileCoverageModeRaw = core.getInput('file-coverage-mode');\n  const fileCoverageMode = getCoverageModeFrom(fileCoverageModeRaw);\n\n  const jsonSummaryPath = path.resolve(\n    workingDirectory,\n    core.getInput('json-summary-path') || 'coverage/coverage-summary.json'\n  );\n  const jsonFinalPath = path.resolve(\n    workingDirectory,\n    core.getInput('json-final-path') || 'coverage/coverage-final.json'\n  );\n\n  const jsonSummaryCompareInput = core.getInput('json-summary-compare-path');\n  let jsonSummaryComparePath: string | null = null;\n  if (jsonSummaryCompareInput) {\n    jsonSummaryComparePath = path.resolve(\n      workingDirectory,\n      jsonSummaryCompareInput\n    );\n  }\n\n  const name = core.getInput('name');\n\n  // Get the user-defined pull-request number and perform input validation\n  const prNumber = core.getInput('pr-number');\n  let processedPrNumber: number | undefined = Number(prNumber);\n  if (!Number.isSafeInteger(processedPrNumber) || processedPrNumber <= 0) {\n    processedPrNumber = undefined;\n  }\n  if (processedPrNumber) {\n    core.info(`Received pull-request number: ${processedPrNumber}`);\n  }\n\n  // ViteConfig is optional, as it is only required for thresholds. If no vite config is provided, we will not include thresholds in the final report.\n  const viteConfigPath = await getViteConfigPath(\n    workingDirectory,\n    core.getInput('vite-config-path')\n  );\n  const thresholds = viteConfigPath\n    ? await parseCoverageThresholds(viteConfigPath)\n    : {};\n\n  return {\n    fileCoverageMode,\n    jsonFinalPath,\n    jsonSummaryPath,\n    jsonSummaryComparePath,\n    name,\n    thresholds,\n    workingDirectory,\n    processedPrNumber,\n  };\n}\n","import { createWriteStream, existsSync, mkdirSync } from 'fs';\nimport https from 'https';\nimport { resolve } from 'path';\nimport { CoverageReport } from '../types/JsonSummary.js';\n\n/**\n * Generate a shields.io URL for a badge.\n * Change the color of the badge based on the percentage.\n *\n * @param summaryData The coverage summary report data.\n * @param summaryKey  The summary key to display on the badge.\n * @returns The shields.io URL.\n */\nconst generateUrl = (\n  summaryData: CoverageReport,\n  summaryKey: keyof CoverageReport\n) => {\n  const percentage = summaryData[summaryKey].pct;\n  let color = 'brightgreen';\n  if (percentage < 70) {\n    color = 'red';\n  } else if (percentage < 80) {\n    color = 'yellow';\n  } else if (percentage < 90) {\n    color = 'orange';\n  }\n  return `https://img.shields.io/badge/coverage%3A${summaryKey}-${percentage}%25-${color}.svg`;\n};\n\n/**\n * Download a badge from shields.io.\n * @param url The shields.io URL.\n * @param filename The filename to save the badge to.\n * @return Promise<void>\n */\nconst downloadBadge = (url: string, filename: string) => {\n  return new Promise<void>((resolve, reject) => {\n    https.get(url, (res) => {\n      if (res.statusCode !== 200) {\n        const newError = new Error(\n          `Error downloading badge: ${res.statusMessage}`\n        );\n        console.error(newError);\n        return reject(newError);\n      }\n\n      const file = createWriteStream(filename);\n      res.pipe(file);\n      file.on('finish', () => {\n        file.close();\n        resolve();\n      });\n      file.on('error', (err) => {\n        console.error(`Error saving badge: ${err}`);\n        reject(err);\n      });\n    });\n  });\n};\n\n/**\n * Generate badges for code coverage.\n */\nexport type GenerateBadgesOptions = {\n  /**\n   * The path to the coverage json file.\n   */\n  totalCoverageReport: CoverageReport;\n  /**\n   * The directory to save the badges to.\n   */\n  badgesSavedTo: string;\n};\n\n/**\n * Generate badges for code coverage.\n */\nexport const generateBadges = async (options: GenerateBadgesOptions) => {\n  const { badgesSavedTo, totalCoverageReport } = options;\n\n  // Construct the shields.io URL for each badge.\n  const statementsBadgeUrl = generateUrl(totalCoverageReport, 'statements');\n  const branchesBadgeUrl = generateUrl(totalCoverageReport, 'branches');\n  const functionsBadgeUrl = generateUrl(totalCoverageReport, 'functions');\n  const linesBadgeUrl = generateUrl(totalCoverageReport, 'lines');\n\n  // Create the badges directory if it does not exist.\n  if (!existsSync(badgesSavedTo)) {\n    mkdirSync(badgesSavedTo);\n  }\n\n  // Download each badge and save it to the badges directory.\n  await downloadBadge(\n    statementsBadgeUrl,\n    resolve(badgesSavedTo, 'statements.svg')\n  );\n  await downloadBadge(\n    functionsBadgeUrl,\n    resolve(badgesSavedTo, 'functions.svg')\n  );\n  await downloadBadge(linesBadgeUrl, resolve(badgesSavedTo, 'lines.svg'));\n  await downloadBadge(branchesBadgeUrl, resolve(badgesSavedTo, 'branches.svg'));\n\n  console.log('Code coverage badges created successfully.');\n};\n","import minimist from 'minimist';\nimport { resolve } from 'path';\nimport { parseVitestJsonSummary } from './inputs/parseVitestJsonReports.js';\nimport { readOptions } from './inputs/readOptions.js';\nimport { generateBadges } from './report/generateBadges.js';\n\ntype Argv = {\n  p: string;\n  path: string;\n};\n\nexport const main = async (args: string[]) => {\n  const argv = minimist<Argv>(args, {\n    '--': true,\n    alias: {\n      p: 'path',\n    },\n    default: {\n      p: 'coverage/badges',\n    },\n  });\n\n  const badgesSavedTo = resolve(process.cwd(), argv.path);\n  const { jsonSummaryPath } = await readOptions();\n  const jsonSummary = await parseVitestJsonSummary(jsonSummaryPath);\n\n  return generateBadges({\n    badgesSavedTo,\n    totalCoverageReport: jsonSummary.total,\n  });\n};\n"]}